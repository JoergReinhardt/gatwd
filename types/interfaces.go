package types

// VALUES AND TYPES
///////////////////
// TYPED //
type Destructable interface{ Clear() }
type Reproduceable interface{ Copy() Data }
type Printable interface{ String() strVal }

///// FLAT VALUES ///////

/// marks the 'principle' type of an instance of either data, or functions
//alike. every higher type, generated by the user or the type system via
//inference, can be identified as instance, of exactly one of those principle
//types.

/// each funcrtion type definition, genereates a higher type. polymorphic types
// generate further types, by type construction in combination with the passed
// in types, when instanciated.
//
// each type definition has a unique name, signature (both can be derived).
// associated wit the unique name (type identity) are/is the actual function
// implementation(s). they all have the same function name, but different
// signatures regarding their input parameters. the implementation to call we
// be inferred during runtime.  and a principle type (s.a).
type Typed interface{ Type() flag }
type Data interface {
	Typed
}
type Function interface {
	Typed
	Name() strVal
}

///// COLLECTIONS ///////
type Collected interface {
	Empty() boolVal
}

/// FLAT COLLECTIONS /////
type Ordered interface {
	Collected
	Next() Data
}
type Reverseable interface {
	Ordered
	Prev() Data
}
type Limited interface {
	Len() intVal
}
type Attributed interface {
	AttrType() Typed
	Get(Data) Data
}

//// LAST IN FIRST OUT //////
type Stacked interface {
	Collected
	Push(Data)
	Pop() Data
	Add(...Data)
}

//// FIRST IN FIRST OUT /////
type Queued interface {
	Collected
	Put(Data)
	Pull() Data
	Append(...Data)
}

/// NESTED COLLECTIONS /////
type Nested interface {
	Collected()
	Decap() (Data, Nested)
	Head() Data
	Tail() Nested
}
type Tupled interface {
	Nested
	Arity() intVal  // number of fields
	MemNum() intVal // number of fields set
	Get(i intVal) Data
}

//////////////////////////
// input item data interface
type Item interface {
	ItemType() Typed
	Idx() int
	Value() Data
}

//////////////////////////
// interfaces dealing with instances of input items
type Queue interface {
	Next()
	Peek() Item
	Current() Item
	Idx() int
}

///////////////////////
type State interface {
	Queue
	Run()
	ItemType() Typed
	State(string) StateFn
}

// takes a state and advances it. returns the next state fn to run
type StateFn func(State) StateFn

func (p StateFn) Type() Typed { return StateFunc.Type() }

// a thing that can be changed by calling the args method passing a parameter
// function. the parameter function gets called with the parametric instance as
// it's argument and returns an altered version of the instance and a new
// parameter function that closes over the old set of parameters to enable a
// possible rollback to the former instance state.
type Parametric interface {
	Params(ParamFn) (Parametric, ParamFn)
}

//go:generate stringer -type=FnType
const (
	StateFunc FnType = 1 << iota
	ParamFunc
)

type FnType uint

func (t FnType) Type() Typed { return t.Type() }
func (t FnType) Flag() flag  { return flag(t) }

// function to change parameters and return the changed instance accompanied by
// the new ParamFn closing over the replaced arguments
type ParamFn func(Parametric) (Parametric, ParamFn)

func (p ParamFn) Type() Typed { return ParamFunc.Type() }

// data to parse
type Token interface {
	Type() TokenType
	String() string
}
