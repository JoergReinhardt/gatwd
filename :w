package lex

import (
	"strings"

	d "github.com/JoergReinhardt/godeep/data"
	"github.com/olekukonko/tablewriter"
)

///// SYNTAX DEFINITION /////
type SyntaxItemFlag d.BitFlag

func (t SyntaxItemFlag) Flag() d.BitFlag      { return d.BitFlag(t) }
func (t SyntaxItemFlag) Type() SyntaxItemFlag { return t }
func (t SyntaxItemFlag) Syntax() string       { return syntax[t] }

// all syntax items represented as string
func AllSyntax() string {
	str := &strings.Builder{}
	tab := tablewriter.NewWriter(str)
	for _, t := range AllItems() {
		row := []string{
			t.String(), syntax[t], matchSyntax[syntax[t]],
		}
		tab.Append(row)
	}
	tab.Render()
	return str.String()
}

// slice of all syntax items in there int constant form
func AllItems() []SyntaxItemFlag {
	var tt = []SyntaxItemFlag{}
	var i uint
	var t SyntaxItemFlag = 0
	for i < 63 {
		t = 1 << i
		i = i + 1
		tt = append(tt, SyntaxItemFlag(t))
	}
	return tt
}
func Itemize(expression string) (res []Item) {
	var tmp = []Item{}
	for n, field := range strings.Fields(expression) {
		tmp = append(tmp, itemizeField(field)...)
		if n < len(strings.Fields(expression))-1 {
			tmp = append(tmp, syntaxItem(Blank))
		}
	}
	// return final result
	return res
}
func itemizeField(field string) (res []Item) {
	if item, ok := isSyntax(field); ok {
		res = append(res, item)
	}
	if item, ok := isKeyWord(field); ok {
		res = append(res, item)
	}
	if item, ok := isAllNumbers(field); ok {
		res = append(res, item)
	}
	if isAllLetters(field) {
		if item, ok := hasLowerCasePrefix(field); ok {
			res = append(res, item)
		}
		if item, ok := hasCapitalPrefix(field); ok {
			res = append(res, item)
		}
	}
	// nothing matched so far, further investigation into what to
	// split is in order‥.
	if items, ok := hasSyntaxSuffix(field); ok {
		for _, item := range items {
			res = append(res, Itemize(item))
		}
	}
	if items, ok := isSeperatedBySyntax(field); ok {
		for _, item := range items {
			res = append(res, Itemize(item))
		}
	}
	if items, ok := hasSyntaxPrefix(field); ok {
		for _, item := range items {
			res = append(res, Itemize(item))
		}
	}
	return res
}

// part of an expression recognized as nothing but a syntactic token.
func isSyntax(str string) (Item, bool) {
	if item, ok := match[str]; ok {
		return syntaxItem(item), true
	}
	return nil, false
}

// if it contains syntax, but fails to 'be' syntax, it must be a concatenation
// of items not seperated by whitespace, (which is where things get messy)
func containsSyntax(str string) (Item, bool) {
	if strings.ContainsAny(str, AllSyntax()) {
		return stringItem{StringItem, str}, true
	}
	return nil, false
}

// item concatenation is either prefixed, or suffixed by syntax element.
// item concatenation is either prefixed, or suffixed by syntax element.
func hasSyntaxSuffix(str string) ([]string, bool) {
	var res = []string{}
	var has = false
	// check for every syntax item if it's possibly either‥.
	for _, item := range AllItems() {
		var praed = item.Syntax()
		if strings.HasSuffix(str, praed) {
			has = true
			res = append(res, strings.TrimSuffix(str, praed), praed)
		}
	}
}
func hasSyntaxPrefix(str string) ([]string, bool) {
	var has = false
	var res = []string{}
	// check for every syntax item if it's possibly either‥.
	for _, item := range AllItems() {
		var praed = item.Syntax()
		if strings.HasPrefix(str, praed) {
			has = true
			res = append(res, praed, strings.TrimPrefix(str, praed))

		}
	}
	return res
}

// if concatenation contains syntax elements, that are neither suffix, nor
// prefix, they must seperate two or more other parts‥.
func isSeperatedBySyntax(str string) ([]string, bool) {
	var res = []string{}
	var has = false
	for _, item := range AllItems() {
		var praed = item.Syntax()
		if strings.Contains(str, praed) {
			has = true
			var stra = strings.Split(str, praed)
			var l = len(stra)
			for n, str := range stra {
				res = append(res, str)
				if n < l-1 { // replace the seperators, eliminated by strings.split
					res = append(res, " ")
				}
			}
		}
	}
}
func isKeyWord(str string) (Item, bool) {
	for word, tok := range keywords {
		if strings.Compare(str, word) == 0 {
			return stringItem{tok, str}, true
		}
	}
	return syntaxItem(SyntaxItemFlag(0)), false
}
func containsKeyWord(str string) (Item, bool) {
	for word, tok := range keywords {
		if strings.Contains(str, word) {
			return stringItem{tok, str}, true
		}
	}
	return syntaxItem(SyntaxItemFlag(0)), false
}
func hasCapitalPrefix(str string) (Item, bool) {
	if strings.HasPrefix(str, "ABCDEFGHIJKLMNOPRSTUVWXYZ") {
		return stringItem{TypeIdent, str}, true
	}
	return nil, false
}
func hasLowerCasePrefix(str string) (Item, bool) {
	if strings.HasPrefix(str, "abcdefghijklmnoprstuvwxyzßäöü") {
		return stringItem{FuncIdent, str}, true
	}
	return nil, false
}
func isAllNumbers(str string) (Item, bool) {
	for _, r := range []rune(str) {
		if !strings.Contains(string(r), "0123456789") {
			return nil, false
		}
	}
	return stringItem{NumeralItem, str}, true
}
func containsNumerals(str string) (Item, bool) {
	if strings.ContainsAny(str, "0123456789") {
		return stringItem{NumeralItem, str}, true
	}
	return nil, false
}
func containsLetters(str string) (Item, bool) {
	if strings.ContainsAny(str, "abcdefghijklmnoprstuvwxyzßäöüABCDEFGHIJKLMNOPRSTUVWXYZ") {
		return stringItem{StringItem, str}, true
	}
	return nil, false
}
func isAllLetters(str string) bool {
	for _, r := range []rune(str) {
		if !strings.ContainsAny(string(r), "abcdefghijklmnoprstuvwxyzßäöüABCDEFGHIJKLMNOPRSTUVWXYZ") {
			return false
		}
	}
	return true
}

//go:generate stringer -type=SyntaxItemFlag
const (
	None  SyntaxItemFlag = 1
	Blank SyntaxItemFlag = 1 << iota
	Underscore
	Asterisk
	Dot
	Comma
	Colon
	Semicolon
	Minus
	Plus
	Or
	Xor
	And
	Equal
	Lesser
	Greater
	Lesseq
	Greaterq
	LeftPar
	RightPar
	LeftBra
	RightBra
	LeftCur
	RightCur
	Slash
	Pipe
	Not
	Unequal
	Dec
	Inc
	DoubEqual
	TripEqual
	RightArrow
	LeftArrow
	FatLArrow
	FatRArrow
	DoubCol
	Sing_quote
	Doub_quote
	BckSla
	Lambda
	HeadWord
	TailWord
	InWord
	ConWord
	LetWord
	MutableWord
	WhereWord
	OtherwiseWord
	IfWord
	ThenWord
	ElseWord
	CaseWord
	OfWord
	DataWord
	TypeWord
	StringItem
	NumeralItem
	FuncIdent
	TypeIdent

	// parts of syntax that constitute indipendent items, but commonly end
	// up concatenated to other items without seperating space character to
	// split by, which results in the need for further processing.
	Appendices = Dot | Comma | Colon | Semicolon | LeftPar | RightPar | LeftBra |
		RightBra | LeftCur | RightCur
)

var keywords = map[string]SyntaxItemFlag{
	"in":        InWord,
	"con":       ConWord,
	"let":       LetWord,
	"mutable":   MutableWord,
	"where":     WhereWord,
	"otherwise": OtherwiseWord,
	"if":        IfWord,
	"then":      ThenWord,
	"else":      ElseWord,
	"case":      CaseWord,
	"of":        OfWord,
	"data":      DataWord,
	"type":      TypeWord,
}

var matchSyntax = map[string]string{
	"⊥":  "",
	" ":  " ",
	"_":  "_",
	"∗":  "*",
	".":  ".",
	",":  ",",
	":":  ":",
	";":  ";",
	"-":  "-",
	"+":  "+",
	"∨":  "OR",
	"※":  "XOR",
	"∧":  "AND",
	"=":  "=",
	"≪":  "<<",
	"≫":  ">>",
	"≤":  "=<",
	"≥":  ">=",
	"(":  "(",
	")":  ")",
	"[":  "[",
	"]":  "]",
	"{":  "{",
	"}":  "}",
	"/":  "/",
	"¬":  "!",
	"≠":  "!=",
	"--": "--",
	"++": "++",
	"==": "==",
	"≡":  "===",
	"→":  "->",
	"←":  "<-",
	"⇐":  "<=",
	"⇒":  "=>",
	"∷":  "::",
	`'`:  `'`,
	`"`:  `"`,
	`\`:  `\`,
	"λ":  "\\x",
	"x":  "x",
	"xs": "xs",
}
var syntax = map[SyntaxItemFlag]string{
	None:       "⊥",
	Blank:      " ",
	Underscore: "_",
	Asterisk:   "∗",
	Dot:        ".",
	Comma:      ",",
	Colon:      ":",
	Semicolon:  ";",
	Minus:      "-",
	Plus:       "+",
	Or:         "∨",
	Xor:        "※",
	And:        "∧",
	Equal:      "=",
	Lesser:     "≪",
	Greater:    "≫",
	Lesseq:     "≤",
	Greaterq:   "≥",
	LeftPar:    "(",
	RightPar:   ")",
	LeftBra:    "[",
	RightBra:   "]",
	LeftCur:    "{",
	RightCur:   "}",
	Slash:      "/",
	Pipe:       "|",
	Not:        "¬",
	Unequal:    "≠",
	Dec:        "--",
	Inc:        "++",
	DoubEqual:  "==",
	TripEqual:  "≡",
	RightArrow: "→",
	LeftArrow:  "←",
	FatLArrow:  "⇐",
	FatRArrow:  "⇒",
	DoubCol:    "∷",
	Sing_quote: `'`,
	Doub_quote: `"`,
	BckSla:     `\`,
	Lambda:     "λ",
	HeadWord:   "x",
	TailWord:   "xs",
}
var match = map[string]SyntaxItemFlag{
	"":    None,
	" ":   Blank,
	"_":   Underscore,
	"*":   Asterisk,
	".":   Dot,
	",":   Comma,
	":":   Colon,
	";":   Semicolon,
	"-":   Minus,
	"+":   Plus,
	"OR":  Or,
	"XOR": Xor,
	"AND": And,
	"=":   Equal,
	"<<":  Lesser,
	">>":  Greater,
	"=<":  Lesseq,
	">=":  Greaterq,
	"(":   LeftPar,
	")":   RightPar,
	"[":   LeftBra,
	"]":   RightBra,
	"{":   LeftCur,
	"}":   RightCur,
	"/":   Slash,
	"|":   Pipe,
	"!":   Not,
	"!=":  Unequal,
	"--":  Dec,
	"++":  Inc,
	"==":  DoubEqual,
	"===": TripEqual,
	"->":  RightArrow,
	"<-":  LeftArrow,
	"<=":  FatLArrow,
	"=>":  FatRArrow,
	"::":  DoubCol,
	`'`:   Sing_quote,
	`"`:   Doub_quote,
	`\`:   BckSla,
	"\\x": Lambda,
	"x":   HeadWord,
	"xs":  TailWord,
}

// checks if a string matches any representation of a syntax item and yields
// it, if that's the case
func MatchString(tos string) Item { return syntaxItem(match[tos]) }

// convert item string representation from editable to pretty
func ASCIIToUtf8(tos ...string) []SyntaxItemFlag {
	var ti = []SyntaxItemFlag{}
	for _, s := range tos {
		ti = append(ti, match[s])
	}
	return ti
}

// convert item string representation from pretty to editable
func Utf8ToASCII(tos ...string) string {
	var sto string
	for _, s := range tos {
		sto = sto + matchSyntax[s]
	}
	return sto
}

// item is a bitflag of course
type Item interface {
	Flag() d.BitFlag
	Type() SyntaxItemFlag
	String() string
}

type syntaxItem d.BitFlag
type stringItem struct {
	SyntaxItemFlag
	string
}

func (t syntaxItem) Type() SyntaxItemFlag { return SyntaxItemFlag(t.Flag()) }
func (t stringItem) Type() SyntaxItemFlag { return SyntaxItemFlag(t.Flag()) }

// pretty utf-8 version of syntax item
func (t syntaxItem) String() string { return SyntaxItemFlag(t.Flag()).Syntax() }
func (t stringItem) String() string { return t.string }

// provides an alternative string representation that can be edited without
// having to produce utf-8 digraphs
func (t syntaxItem) StringAlt() string { return matchSyntax[syntax[SyntaxItemFlag(t.Flag())]] }
func (t stringItem) StringAlt() string { return matchSyntax[syntax[SyntaxItemFlag(t.Flag())]] }
func (t syntaxItem) Flag() d.BitFlag   { return d.Flag.Flag() }
func (t stringItem) Flag() d.BitFlag   { return d.Flag.Flag() }
