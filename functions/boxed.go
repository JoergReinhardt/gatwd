/*
  HIGHER ORDER TYPES

  new higher order type definition, expects a name and a consumeable of
  constructors as its arguments.

  the constructors are expected to contain all necessary typechecks, data-/
  and type constructors to instanciate values of the type. when called with
  arguments, a higher order type will try to instanciate them as valus of it's
  type and return those. data-/ & type constructors are expected to return a
  boolean as second value, to check if instanciation was successfull. if
  unsuccssessfull constructors need to return  the arguments been passed with
  the call as first value to be passed on to the next constructor in the list
  of constructors until either instanciation was successfull, or all
  constructors have been tryed unsuccssessfully.
*/
package functions

import (
	d "github.com/joergreinhardt/gatwd/data"
)

type (
	// HIGHER ORDER TYPES
	HOTypeCon func(...Callable) (string, Consumeable)

	///// MONOIDAL TYPE CONSTRUCTORS
	//
	// ATOMIC TYPE CONSTRUCTOR
	//
	// atomic types are funtions that return values of a predifined static
	// type that can not be divided any further, indipendant from the types
	// of arguments given when called (if they take any arguments in the
	// first place). They are the leafes in the tree of types.
	//
	// the atomic type contructor expects a callable instance of the
	// underlying callable as it's argument.
	//
	// the name argument is optional and will be autogenerated from the
	// name of the functional type (TyFnc) of the constructor instance.
	AtomicTypeCon func(constructor Callable, name ...string) (HOTypeCon, bool)

	// PRIMARY TYPE CONSTRUCTOR
	//
	// primary value type is also kind of a leafe in the tree of types.
	// They aren't neccessary atomic since native types like slices and
	// maps are compositions, but in cases where those end up the return
	// value of a 'Callable', they are most likely meant to get treated as
	// single unboxed value for reasons of performance, in the first place.
	PrimeTypeCon func(constructor d.Native, name ...string) (HOTypeCon, bool)

	// TYPE ALIAS CONSTRUCTOR
	//
	// type aliases bind given higher order types to dedicated names.
	AliasTypeCon func(original HOTypeCon, name string) (HOTypeCon, bool)

	// SUM TYPE CONSTRUCTOR
	//
	// sum type composes a higher order type constructor from it's  passed
	// arguments. a distinct name for the type can be passed in as last
	// argument, orherwise the name get's composed from the names of its
	// subtypes.
	SumTypeCon func(
		members []HOTypeCon, name ...string,
	) (
		HOTypeCon, bool,
	)

	// PRODUCT TYPE CONSTRUCTOR
	//
	// product types are atomic, native, or composed types, that generate
	// subtypes based on the types of arguments passed at runtime.
	ProductTypeCon func(
		members []HOTypeCon, constructors Consumeable,
		name ...string,
	) (
		HOTypeCon, bool,
	)

	//// MONADIC TYPE SIGNATURES
	///
	// every possible signature of arguments passed to a monadic type can
	// be expressed by a variadic argument of the Callable interface type.
	// type checking of arguments is dynamic and performed during either
	// run- or compiletime.
	//
	// to provide type safety in a performant manner, gatwd relies on
	// golangs ability to return multiple values, by returning the result
	// adjoined by another value indicating the outcom of a computation of
	// a monadic type.

	// TRUTH TYPE VALUES
	//
	TruthTypeVal func(...Callable) bool

	// NATIVE TYPE VALUES
	NatTypeVal func(...d.Native) d.Native

	// SUM TYPE VALUES
	FncTypeVal func(...Callable) Callable

	// PAIRS OF VALUES
	PairTypeVal func(...Callable) (Callable, Callable)

	// SLICES OF VALUES
	VecTypeVal func(...Callable) []Callable

	// SEQUENCE OF ASSOCIATIVE VALUES
	AssocTypeVal func(...PairTypeVal) []PairTypeVal

	// SETS OF VALUES
	SetTypeVal func(...PairTypeVal) d.Mapped

	// RECURSIVE VALUES (LISTS & MONADS)
	RecursiveTypeVal func(...Callable) (Callable, Consumeable)
)

// NewHOType(name string, constructors Consumeable) HOType returns a
//
// constructor for a new higher order type as defined by the passed arguments.
func NewHOType(name string, constructors Consumeable) HOTypeCon {
	return HOTypeCon(func(args ...Callable) (string, Consumeable) {
		return name, constructors
	})
}

func (c HOTypeCon) Ident() Callable                { return c }
func (c HOTypeCon) TypeNat() d.TyNative            { return d.Flag }
func (c HOTypeCon) TypeFnc() TyFnc                 { return HigherOrder | Type }
func (c HOTypeCon) String() string                 { return "higher order type" }
func (c HOTypeCon) Call(args ...Callable) Callable { return c }
func (c HOTypeCon) Eval(args ...d.Native) d.Native { return c.Eval() }

func (c SumTypeCon) Ident() Callable                { return c }
func (c SumTypeCon) TypeFnc() TyFnc                 { return Type }
func (c SumTypeCon) TypeNat() d.TyNative            { return d.Flag }
func (c SumTypeCon) Call(args ...Callable) Callable { return c }
func (c SumTypeCon) Eval(args ...d.Native) d.Native { return c.Eval() }
func (c SumTypeCon) String() string                 { return "sum type" }

func (c ProductTypeCon) Ident() Callable                { return c }
func (c ProductTypeCon) TypeFnc() TyFnc                 { return Type }
func (c ProductTypeCon) TypeNat() d.TyNative            { return d.Flag }
func (c ProductTypeCon) Call(args ...Callable) Callable { return c }
func (c ProductTypeCon) Eval(args ...d.Native) d.Native { return c.Eval() }
func (c ProductTypeCon) String() string                 { return "product type" }

func (c PrimeTypeCon) Ident() Callable                { return c }
func (c PrimeTypeCon) TypeFnc() TyFnc                 { return Type }
func (c PrimeTypeCon) TypeNat() d.TyNative            { return d.Flag }
func (c PrimeTypeCon) Call(args ...Callable) Callable { return c }
func (c PrimeTypeCon) Eval(args ...d.Native) d.Native { return c.Eval() }
func (c PrimeTypeCon) String() string                 { return "primary type" }

func (c FncTypeVal) Ident() Callable                { return c }
func (c FncTypeVal) TypeFnc() TyFnc                 { return Type }
func (c FncTypeVal) TypeNat() d.TyNative            { return d.Flag }
func (c FncTypeVal) Call(args ...Callable) Callable { return c }
func (c FncTypeVal) Eval(args ...d.Native) d.Native { return c.Eval() }
func (c FncTypeVal) String() string                 { return "sum type constructor" }
