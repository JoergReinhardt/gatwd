/*
  HIGHER ORDER TYPES

  new higher order type definition, expects a name and a consumeable of
  constructors as its arguments.

  the constructors are expected to contain all necessary typechecks, data-/
  and type constructors to instanciate values of the type. when called with
  arguments, a higher order type will try to instanciate them as valus of it's
  type and return those. data-/ & type constructors are expected to return a
  boolean as second value, to check if instanciation was successfull. if
  unsuccssessfull constructors need to return  the arguments been passed with
  the call as first value to be passed on to the next constructor in the list
  of constructors until either instanciation was successfull, or all
  constructors have been tryed unsuccssessfully.
*/
package functions

import (
	d "github.com/joergreinhardt/gatwd/data"
)

type (
	// HIGHER ORDER TYPES
	HOTypeCon func(...Callable) (string, Consumeable)

	// TYPE ALIAS CONSTRUCTOR
	//
	// type aliases bind given higher order types to dedicated names.
	AliasTypeCon func(original HOTypeCon, name string) (HOTypeCon, bool)

	///// MONOIDAL TYPE CONSTRUCTORS
	//
	// ATOMIC TYPE CONSTRUCTOR
	//
	// atomic types are funtions that return values of a predifined static
	// type that can not be divided any further, indipendant from the types
	// of arguments given when called (if they take any arguments in the
	// first place). They are the leafes in the tree of types.
	//
	// the atomic type contructor expects a callable instance of the
	// underlying callable as it's argument.
	//
	// the name argument is optional and will be autogenerated from the
	// name of the functional type (TyFnc) of the constructor instance.
	AtomicTypeCon func(constructor Callable, name ...string) (HOTypeCon, bool)

	// PRIMARY TYPE CONSTRUCTOR
	//
	// primary value type is also kind of a leafe in the tree of types.
	// They aren't neccessary atomic since native types like slices and
	// maps are compositions, but in cases where those end up the return
	// value of a 'Callable', they are most likely meant to get treated as
	// single unboxed value for reasons of performance, in the first place.
	PrimeTypeCon func(constructor d.Native, name ...string) (HOTypeCon, bool)

	// SUM TYPE CONSTRUCTOR
	//
	// sum type composes a higher order type constructor from it's  passed
	// arguments. a distinct name for the type can be passed in as last
	// argument, orherwise the name get's composed from the names of its
	// subtypes.
	SumTypeCon func(
		members []HOTypeCon, name ...string,
	) (
		HOTypeCon, bool,
	)

	// PRODUCT TYPE CONSTRUCTOR
	//
	// product types are atomic, native, or composed types, that generate
	// subtypes based on the types of arguments passed at runtime.
	ProductTypeCon func(
		members []HOTypeCon, constructors Consumeable,
		name ...string,
	) (
		HOTypeCon, bool,
	)

	//// MONADIC TYPE SIGNATURES
	///
	// every possible signature of arguments passed to a monadic type can
	// be expressed by a variadic argument of the Callable interface type.
	// type checking of arguments is dynamic and performed during either
	// run- or compiletime.
	//
	// to provide type safety in a performant manner, gatwd relies on
	// golangs ability to return multiple values, by returning the result
	// adjoined by another value indicating the outcom of a computation of
	// a monadic type.

	// SUM TYPE VALUES
	ExprTypeVal func(...Callable) Callable

	// TRUTH TYPE VALUES
	TruthTypeVal func(...Callable) bool

	// NATIVE TYPE VALUES
	NatTypeVal func(...d.Native) d.Native

	// PAIRS OF VALUES
	PairTypeVal func(...Callable) (Callable, Callable)

	// SLICES OF VALUES
	VecTypeVal func(...Callable) []Callable

	// SEQUENCE OF ASSOCIATIVE VALUES
	AssocTypeVal func(...PairTypeVal) []PairTypeVal

	// SETS OF VALUES
	SetTypeVal func(...PairTypeVal) d.Mapped

	// RECURSIVE VALUES (LISTS & MONADS)
	RecursiveTypeVal func(...Callable) (Callable, Consumeable)
)

//// GENERIC HIGHER ORDER TYPE
///
//
func NewHOType(name string, constructors Callable) HOTypeCon {

	return HOTypeCon(func(args ...Callable) (string, Consumeable) {

		return name, NewList(constructors)
	})
}

func (c HOTypeCon) Ident() Callable                { return c }
func (c HOTypeCon) Name() string                   { name, _ := c(); return name }
func (c HOTypeCon) Constructors() Consumeable      { _, cons := c(); return cons }
func (c HOTypeCon) TypeNat() d.TyNative            { return d.Flag | d.Function }
func (c HOTypeCon) TypeFnc() TyFnc                 { return HigherOrder | Type | Constructor }
func (c HOTypeCon) String() string                 { return "higher order type constructor" }
func (c HOTypeCon) Call(args ...Callable) Callable { return c }
func (c HOTypeCon) Eval(args ...d.Native) d.Native { return c.Eval() }
func (c HOTypeCon) Signature() []Callable {
	return []Callable{
		NewFromFlag(HigherOrder),
		NewFromFlag(Type),
		NewFromFlag(Constructor),
	}
}

//// HIGHER ORDER TYPE ALIAS
///
//
func NewAliasType(name string, hot HOTypeCon) HOTypeCon {

	return HOTypeCon(func(args ...Callable) (string, Consumeable) {

		return name, NewList(hot.Constructors())
	})
}
func (c AliasTypeCon) Ident() Callable                { return c }
func (c AliasTypeCon) TypeFnc() TyFnc                 { return HigherOrder | Type }
func (c AliasTypeCon) TypeNat() d.TyNative            { return d.Flag | d.Function }
func (c AliasTypeCon) Call(args ...Callable) Callable { return c }
func (c AliasTypeCon) Eval(args ...d.Native) d.Native { return c.Eval() }
func (c AliasTypeCon) String() string                 { return "alias type constructor" }
func (c AliasTypeCon) Signature() []Callable {
	return []Callable{
		NewFromFlag(HigherOrder),
		NewFromFlag(Type),
		NewFromFlag(Constructor),
	}
}

//// HIGHER ORDER SUM TYPE
///
//
func (c SumTypeCon) Ident() Callable                { return c }
func (c SumTypeCon) TypeFnc() TyFnc                 { return HigherOrder | Type | TypeSum }
func (c SumTypeCon) TypeNat() d.TyNative            { return d.Flag | d.Function }
func (c SumTypeCon) Call(args ...Callable) Callable { return c }
func (c SumTypeCon) Eval(args ...d.Native) d.Native { return c.Eval() }
func (c SumTypeCon) String() string                 { return "sum type constructor" }
func (c SumTypeCon) Signature() []Callable {
	return []Callable{
		NewFromFlag(HigherOrder),
		NewFromFlag(TypeSum),
		NewFromFlag(Constructor),
	}
}

//// HIGHER ORDER PRODUCT TYPE
///
//
func (c ProductTypeCon) Ident() Callable                { return c }
func (c ProductTypeCon) TypeFnc() TyFnc                 { return HigherOrder | Type | TypeProduct }
func (c ProductTypeCon) TypeNat() d.TyNative            { return d.Function | d.Flag }
func (c ProductTypeCon) Call(args ...Callable) Callable { return c }
func (c ProductTypeCon) Eval(args ...d.Native) d.Native { return c.Eval() }
func (c ProductTypeCon) String() string                 { return "product type constructor" }
func (c ProductTypeCon) Signature() []Callable {
	return []Callable{
		NewFromFlag(HigherOrder),
		NewFromFlag(TypeProduct),
		NewFromFlag(Constructor),
	}
}

//// HIGHER ORDER PRIMARY VALUE TYPE
///
//
func (c PrimeTypeCon) Ident() Callable                { return c }
func (c PrimeTypeCon) TypeFnc() TyFnc                 { return HigherOrder | Type | Data }
func (c PrimeTypeCon) TypeNat() d.TyNative            { return d.Function | d.Flag }
func (c PrimeTypeCon) Call(args ...Callable) Callable { return c }
func (c PrimeTypeCon) Eval(args ...d.Native) d.Native { return c.Eval() }
func (c PrimeTypeCon) String() string                 { return "primary type constructor" }
func (c PrimeTypeCon) Signature() []Callable {
	return []Callable{
		NewFromFlag(HigherOrder),
		NewFromFlag(Data),
		NewFromFlag(Constructor),
	}
}

//// HIGHER ORDER functional VALUE TYPE
///
//
func (c ExprTypeVal) Ident() Callable                { return c }
func (c ExprTypeVal) TypeFnc() TyFnc                 { return HigherOrder | Expression | Data }
func (c ExprTypeVal) TypeNat() d.TyNative            { return d.Function | d.Flag }
func (c ExprTypeVal) Call(args ...Callable) Callable { return c }
func (c ExprTypeVal) Eval(args ...d.Native) d.Native { return c.Eval() }
func (c ExprTypeVal) String() string                 { return "expression type value" }
func (c ExprTypeVal) Signature() []Callable {
	return []Callable{
		NewFromFlag(HigherOrder),
		NewFromFlag(Expression),
		NewFromFlag(Constructor),
	}
}
